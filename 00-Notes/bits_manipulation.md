# Summary for Bits Manipulation

## 常规位运算需掌握的算法

太棒了，这正是一名优秀选手该有的素质——**从具体题目中抽象出通用模型**。

对于嵌入式岗位或 ACM 竞赛，位运算不仅是性能优化的手段，更是直接操控硬件的基础。我为你总结了一份“位运算实战红宝书”，这些公式建议你刻在肌肉记忆里。

---

### 🛠️ 位运算核心工具箱

#### 1. 基础位提取（The Basic Tools）

这些操作用于精准打击某个特定位。

* **提取第  位**：`(n >> k) & 1` （判断第  位是 0 还是 1）
* **将第  位置为 1**：`n | (1 << k)`
* **将第  位置为 0**：`n & ~(1 << k)`
* **反转第  位**：`n ^ (1 << k)`

#### 2. 判断奇偶性（Odd or Even）

* **逻辑**：奇数的二进制末尾一定是 1，偶数一定是 0。
* **代码**：`if (n & 1)` 为真则是奇数，否则为偶数。
* **优势**：在底层硬件上，`& 1` 的速度通常快于 `% 2`。

#### 3. 2 的幂相关（Power of 2）

这是嵌入式面试最爱考的点，利用了 `n-1` 的特性。

* **判断  是否为 2 的幂**：`n > 0 && (n & (n - 1)) == 0`
* *原理*：原理：2 的幂在二进制中只有一个 1（如 1000），减 1 后变成 0111，两者相与必为 0。

* **获取最低位的那个 1（Lowbit）**：`n & -n`
* *原理*：利用补码特性，这在高级数据结构“树状数组”中是核心操作。



---

### 🧠 高级算法逻辑（The Pro Logic）

#### 4. 位掩码（Bitmask）—— 集合的代称

在竞赛中，我们常用一个整数来表示一个“状态”或“集合”。

* **插入元素 **：`state | (1 << i)`
* **删除元素 **：`state & ~(1 << i)`
* **检查元素  是否在集合中**：`state & (1 << i)`
* **全集**：`(1 << n) - 1`

#### 5. 异或（XOR）的神奇应用

* **不使用临时变量交换两个数**：
```cpp
a ^= b; b ^= a; a ^= b;

```


* **找不同**：如我们刚做的第 136 题，成对抵消。

#### 6. 翻转与镜像

* 就像第 190 题，除了分治法，记住**逐位移动**是基础：
`res = (res << 1) | (n & 1); n >>= 1;`

---

### ⚠️ 嵌入式岗位的“坑”

在面嵌入式岗位时，要注意以下两点：

1. **有符号数与无符号数**：对负数进行右移（`>>`）在 C++ 中是**算术右移**（高位补 1），这可能导致死循环。处理位运算建议一律使用 `unsigned int` 或 `uint32_t`。
2. **位域（Bit-fields）**：虽然不是算法，但面试常问。它允许你在 `struct` 中定义变量占用的位数，以节省内存。

---

### 🚀 教练的下一站建议

位运算的“基础三板斧”你已经练得差不多了。算法世界的另一大支柱是**处理线性空间**的能力。

**你想开启【双指针（Two Pointers）】专题吗？**
这是解决数组、链表题目的神技。我们可以从 **第 141 题：环形链表（快慢指针）** 或者 **第 15 题：三数之和** 开始，看看如何用两个指针在  时间内完成看似不可能的任务。

**准备好迎接更复杂的逻辑挑战了吗？**

## 位域

没问题！作为教练，我非常欣赏这种“打破砂锅问到底”的精神。位运算是**逻辑**，而位域是**内存布局**，这两者结合起来才是完整的嵌入式功底。

---

## 🛠️ 什么是位域（Bit-fields）？

在普通的结构体中，一个 `bool` 或 `char` 至少占用 1 个字节（8 位）。但在嵌入式开发（如控制寄存器、通信协议）中，我们往往需要精确到“位”。

**位域**允许你在结构体中指定每个成员占用的具体位数。

### 1. 代码示例

假设你要定义一个灯光控制器，有 3 个属性：

* 是否开启 (1 bit)
* 亮度级别 (0-7 级，需要 3 bits)
* 颜色模式 (0-3 种，需要 2 bits)

```cpp
struct LightConfig {
    unsigned int isOn     : 1;  // 占用 1 位
    unsigned int brightness : 3;  // 占用 3 位
    unsigned int mode       : 2;  // 占用 2 位
}; // 整个结构体可能只占 4 字节（甚至更少，取决于编译器对对齐的处理）

```

### 2. 面试高频考点

* **内存节省**：如果你用 3 个 `int` 定义上述变量，会占用 12 字节；用位域，它们可以挤在同一个字节里。
* **对齐与填充**：编译器为了读取效率，可能会在位域之间插入空位。
* **无法取地址**：你不能对位域成员使用 `&` 操作符，因为 CPU 寻址的最小单位是**字节**，而不是位。